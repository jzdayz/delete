/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package io.github.jzdayz;

import org.springframework.util.AntPathMatcher;

import java.io.IOException;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class App {

    private static AntPathMatcher antPathMatcher = new AntPathMatcher();

    public static void main(String[] args) throws Exception{
        String deleteDir = System.getProperty("user.dir");
        System.out.println("dir:"+deleteDir);
        if (!(args.length>0)){
            return;
        }
        String pattern = args[0];
        System.out.println("pattern:"+pattern);
        Path path = Paths.get(deleteDir);
        List<Path> deleteLst = new ArrayList<>();
        cyclePath(deleteLst,path,pattern);
        System.out.println("删除文件:");
        deleteLst.forEach(System.out::println);
        Scanner scanner = new Scanner(System.in);
        if (deleteLst.isEmpty()){
            System.out.println("没有可删除的文件...");
            return;
        }
        System.out.println("输入(Y/y)继续:");
        String input = scanner.next();
        if ("Y".equals(input) || "y".equals(input)){
            deleteLst.forEach(deleteFile->{
                try {
                    Files.deleteIfExists(deleteFile);
                    System.out.println("deleted file : "+deleteFile);
                } catch (IOException e) {
                    System.out.println("删除file:"+deleteFile);
                    e.printStackTrace();
                }
            });
        }
    }

    public static void cyclePath(List<Path> map, Path path,final String pattern) throws Exception{
        if (!Files.isDirectory(path)){
            map.add(path);
            return;
        }
        DirectoryStream<Path> paths = Files.newDirectoryStream(path,(currentPa)->{
            // 过滤

            boolean match = antPathMatcher.match(pattern, currentPa.getFileName().toString()) || Files.isDirectory(currentPa);
//            System.out.println(currentPa.getFileName()+"--"+currentPa.toString()+(match?"->true":"->false"));
            return match;
        });
        paths.forEach(pa->{
            try {
                cyclePath(map,pa, pattern);
            } catch (Exception e) {
                e.printStackTrace();
                System.exit(1);
            }
        });
    }
}
